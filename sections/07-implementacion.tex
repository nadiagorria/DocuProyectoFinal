\section{Implementación}
\subsection{Diagrama de Deployment de UML}
El diagrama de Deployment permitió mostrar de manera clara cómo quedó distribuida la arquitectura física del sistema una vez implementado. Allí se identificaron los distintos nodos de hardware y software que intervinieron en la solución, así como la forma en que se organizaron los componentes dentro de la infraestructura disponible. El sistema se desplegó en un servidor virtual de Amazon Web Services (AWS), utilizando una instancia EC2 configurada para ejecutar contenedores Docker. En este entorno se alojaron los servicios del frontend, el backend y la base de datos, los cuales se comunicaron a través de una red interna propia del host.

El diagrama también reflejó la forma en que los usuarios accedieron a la aplicación, ya fuera desde un navegador web o desde la versión móvil como PWA. En ambos casos, la conexión se estableció a través de Internet hacia la dirección pública del servidor EC2. Gracias a esta representación fue posible visualizar de manera sintética cómo se relacionaron los distintos elementos de la solución y cómo se organizó el entorno de despliegue, lo que sirvió como punto de partida para el análisis detallado de las tecnologías utilizadas en el backend y el frontend.
\cite{inia-uy,aws}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth,height=0.6\textheight,keepaspectratio]{\detokenize{Deploy UML.png}}
	\caption{Diagrama de deployment (UML) que muestra la distribución de nodos y contenedores en la infraestructura de despliegue.}
	\label{fig:deploy}
\end{figure}
\subsection{Tecnologías a utilizar}
Las tecnologías empleadas en el proyecto se seleccionaron en función de los requerimientos funcionales, el rendimiento esperado y la necesidad de contar con una arquitectura flexible y mantenible. Se optó por una combinación de herramientas modernas y ampliamente utilizadas en la industria, lo que permitió asegurar un entorno estable durante el desarrollo y el despliegue. La infraestructura se apoyó en contenedores Docker ejecutados sobre una instancia EC2 de AWS, lo que facilitó la portabilidad, el aislamiento y la gestión individual de cada servicio del sistema.

Además, se adoptaron tecnologías que ofrecieron buen soporte para el trabajo con APIs, gestión de datos, desarrollo de interfaces web y compatibilidad con PWA. Esta selección permitió construir una solución sólida y coherente, manteniendo una estructura clara entre la capa de presentación, la capa de negocio y la capa de persistencia.
\subsection{Frontend}
El frontend se construyó con Next.js y TypeScript, una combinación que ofreció un entorno estable para desarrollar interfaces modernas y con buen rendimiento. Next.js permitió implementar renderizado híbrido (SSR/CSR) y optimizaciones automáticas que mejoraron la experiencia del usuario, mientras que TypeScript aportó tipado estático, ayudando a reducir errores y mantener el código más organizado.
\cite{nextjs}

La aplicación también se adaptó como Progressive Web App (PWA), lo que permitió que pudiera instalarse en dispositivos móviles y funcionar con mayor fluidez en entornos donde la conectividad podía ser limitada. Al igual que los demás componentes, el frontend se ejecutó dentro de un contenedor Docker, lo que facilitó su despliegue y mantuvo la coherencia del entorno de ejecución.
\subsection{Backend}
El backend se desarrolló utilizando Java junto con el framework Spring Boot, una tecnología que brindó un conjunto amplio de herramientas para construir servicios web robustos y escalables. Spring Boot permitió organizar la lógica de negocio mediante controladores, servicios y repositorios, además de facilitar la configuración de la API mediante estándares REST. Esta elección favoreció la claridad en la estructura del proyecto y simplificó la integración con el resto de los componentes del sistema.
\cite{spring-boot,junit5,jacoco}

La comunicación con la base de datos se realizó a través de JPA/Hibernate, lo que permitió manejar las entidades del dominio de forma eficiente y reducir la carga de escribir consultas SQL manuales. El servicio funcionó dentro de un contenedor Docker, lo que facilitó su despliegue en la instancia EC2 y garantiza un entorno consistente durante todo el ciclo de vida del proyecto.
\subsection{Horas Dedicadas}
A continuación se detallarán los registros de horas por etapa del proyecto. Estos fueron gestionados utilizando un proyecto en Toggl.
\subsubsection{Etapa 1: Documentación y Análisis}
\textbf{Período:} Desde el 14 de agosto al 08 de septiembre de 2025.
La primera etapa se enfocó principalmente en recolectar la información pertinente con las clientes y documentar las características inicialmente establecidas para comenzar con el desarrollo adecuado de la aplicación web.

Un total de 60 horas fueron dedicadas a esta fase.
\subsubsection{Etapa 2: Desarrollo}
\textbf{Período:} Desde el 08 de septiembre al 08 de noviembre de 2025.
La etapa de desarrollo se dedicó enteramente al desarrollo completo de la aplicación web, cubriendo los requerimientos solicitados y validando con las clientes.

Un total de 553 horas fueron dedicadas a esta fase.
\subsubsection{Etapa 3: Testing, Documentación Final y Presentación}
\textbf{Período:} Desde el 08 de noviembre al 30 de noviembre de 2025.
La etapa final del proyecto se enfocó en la realización de pruebas funcionales y de usabilidad, así como en la corrección de errores detectados. Además, se completó la documentación técnica y se preparó la presentación final del proyecto.
\cite{toggl}

Un total de ?? horas fueron dedicadas a esta fase.