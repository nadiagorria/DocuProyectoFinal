\section{Gestión de Proyecto}
Para la ejecución de este proyecto no se estructuraron roles específicos para cada integrante del equipo. Si bien cada miembro tenía mayor afinidad con determinadas áreas tecnológicas, se decidió adoptar una dinámica de trabajo colaborativa en la que todos participaron tanto en el desarrollo del frontend como el backend, así como en tareas vinculadas a documentación, testing y despliegue.
\cite{inia-uy}

Para la organización del trabajó se creó un proyecto en Notion, donde se registraron las tareas principales, los responsables y las estimaciones de tiempo para cada tarea. 
\cite{notion}

El principal medio de comunicación en línea fue Google Meet, utilizado para reuniones virtuales, donde a su vez se llevaron a cabo reuniones periódicas con el cliente. Además, se creó un grupo de WhatsApp para coordinar rápidamente temas urgentes, notificaciones internas y actualizaciones cortas entre los integrantes del equipo, lo que permitió una comunicación ágil y continua.
\cite{googlemeet,whatsapp}
\subsection{Entorno de Desarrollo}
El desarrollo del sistema se realizó en un entorno orientado a aplicaciones web modernas, priorizando la reproducibilidad, la trazabilidad y la correcta separación de responsabilidades entre los distintos componentes. La arquitectura full-stack del proyecto se implementó utilizando tecnologías ampliamente adoptadas en la industria, con el objetivo de asegurar buenas prácticas de ingeniería, facilitar el mantenimiento y permitir la futura escalabilidad del sistema.
\cite{docker}

Para el desarrollo del software se utilizaron dos entornos de desarrollo integrados (IDE):
\begin{itemize}
    \item Visual Studio Code, empleado principalmente para el frontend y configurado con extensiones específicas para TypeScript, React, Docker y herramientas de control de versiones.
    \cite{vscode}
    \item IntelliJ IDEA, utilizado para el backend en Java, aprovechando su soporte avanzado para Spring Boot, gestión de dependencias con Maven y depuración integrada.
    \cite{intellij}
\end{itemize}
La gestión del código fuente se realizó utilizando Git como sistema de control de versiones y GitHub como plataforma principal de alojamiento, revisión y seguimiento del proyecto. GitHub permitió manejar ramas, realizar revisiones de código, gestionar issues y mantener un flujo de trabajo organizado basado en buenas prácticas de versionado.
\cite{git,github}

Esta combinación permitió a todos los integrantes del equipo trabajar de forma eficiente y con herramientas adecuadas para cada tecnología.
\subsection{Tecnologías utilizadas}
\subsubsection{Cliente}
El cliente del sistema fue diseñado como una aplicación web dinámica utilizando Next.js 14 y React 18, tecnologías ampliamente adoptadas en entornos productivos debido a su eficiencia, modularidad y soporte comunitario.
\cite{nextjs}

La estructura se organizó siguiendo las convenciones del App Router de Next.js, lo cual permitió una clara separación entre páginas, componentes y módulos de lógica, promoviendo escalabilidad y mantenibilidad.

Para el desarrollo de la interfaz de usuario se utilizaron Tailwind CSS, Radix UI y Shadcn. Estas tecnologías permitieron crear una experiencia visual coherente y accesible, con componentes reutilizables y mantenibles, alineados con estándares modernos de diseño.

La comunicación entre el frontend y el backend se realizó mediante APIs REST para la mayor parte de las operaciones, mientras que las funcionalidades en tiempo real se implementaron a través de WebSocket, permitiendo la recepción de notificaciones instantáneas y mejorando la experiencia interactiva del usuario.

El aseguramiento de calidad del frontend incluyó la ejecución de pruebas automatizadas mediante Jest y React Testing Library, herramientas ampliamente utilizadas para validar el comportamiento de componentes y flujos de interacción.
\subsubsection{Servidor}
El backend se implementó utilizando Java 21 con Spring Boot 3.5, aplicando una arquitectura en capas que divide la lógica de negocio, los servicios, los controladores web, los repositorios de datos y las configuraciones transversales. Esta estructura facilita el mantenimiento, reduce el acoplamiento y mejora la estabilidad del sistema.
\cite{spring-boot}
\subsubsection{Servicios y API}
La API del sistema fue documentada utilizando OpenAPI/Swagger, permitiendo que tanto desarrolladores como actores externos comprendan las especificaciones de cada endpoint, formatos de datos, tipos de respuestas y códigos de error.
\cite{openapi}

El backend expone servicios REST y un canal de comunicación en tiempo real mediante WebSocket (STOMP), empleado para enviar notificaciones y eventos relevantes sin necesidad de realizar consultas repetitivas al servidor.
\subsubsection{Persistencia y Base de Datos}
La aplicación utiliza PostgreSQL 15, gestionado mediante Spring Data JPA, lo cual permitió automatizar tareas de persistencia y reducir la necesidad de escribir consultas SQL manuales.
\cite{postgresql}

Durante el proceso de pruebas se utilizó H2, una base de datos en memoria que permite ejecutar los tests de forma rápida, aislada y sin requerir infraestructura externa.
\subsubsection{Seguridad}
La seguridad del sistema se abordó mediante:
\begin{itemize}
    \item Spring Security para la protección de endpoints y control de roles.
    \item JWT para la gestión de sesiones sin estado.
    \item Autenticación en dos pasos (2FA) mediante códigos TOTP, fortaleciendo la seguridad del acceso.
\end{itemize}
Este conjunto de herramientas permitió cumplir buenas prácticas de seguridad alineadas con estándares modernos.
\subsubsection{Herramientas de Construcción, Testing y DevOps}
El backend fue compilado y gestionado mediante Maven, lo que permitió automatizar tareas de instalación, test y empaquetado.

La calidad del código se reforzó mediante pruebas unitarias utilizando JUnit 5 y Mockito, enfocadas en validar la lógica de negocio, la interacción entre módulos y el correcto comportamiento de los componentes críticos.
\cite{junit5,jacoco}

Finalmente, el uso de Docker y Docker Compose permitió ejecutar el proyecto de forma completa (frontend, backend y base de datos) mediante entornos aislados y reproducibles, asegurando coherencia en las diferentes etapas del desarrollo.
\cite{docker}